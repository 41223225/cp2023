var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/41223225/cp2023  \xa0（倉儲） \n \n', 'tags': '', 'url': '關於.html'}, {'title': '布萊頓', 'text': 'https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字符串 （字串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動 Brython 時，設定分割 .py 檔案放入 downloads/py 目錄中引用。 \n 也所有即將對應的 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時交叉 實例 引用。 \n <!-- 啟動 Brython --> \n<腳本> \n視窗.onload=函數(){ \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智能俄羅斯方塊 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': '布萊頓.html'}, {'title': 'W1~W4', 'text': '下載github、replit、teams、Aunthy，把github與Aunthy連結(雙重驗證密碼)，然後再將replit與github連結(上傳檔案) \n \n 網路設定2001:288:6004:17設定完以後cmd中的ip config/all可以查看網路設定 \n replit:先建立倉儲(python)，並與github連接，再將倉儲中設定secrets(密碼鎖)。 \n \n', 'tags': '', 'url': 'W1~W4.html'}, {'title': 'W5', 'text': '// 包含標準輸出入程式庫的標頭文件 \n// https://blog.csdn.net/weixin_38468077/article/details/101069365 \n// http://www.gnuplot.info/demo/ \n// https://github.com/sysprog21/rv32emu \n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3 \n// https://cs61c.org/fa23/ \n// https://greenteapress.com/wp/think-python-2e/ \n// https://github.com/ecalvadi/c99-examples \n// https://github.com/gouravthakur39/beginners-C-program-examples \n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples \n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf \n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf \n// https://jsomers.github.io/cbook/cbook.pdf \n// https://jsomers.github.io/cbook/index.html \n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf \n// http://cslibrary.stanford.edu/101/EssentialC.pdf \n// https://publications.gbdirect.co.uk/c_book/ \n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf \n// ***** 在replit上執行 \n// CD 下載 \n// cc gnuplot_ex1.c -o gnuplot_ex1 \n// ./gnuplot_ex1 \n#include <stdio.h> \n   \n// 主函式 \nint main() { \n    // 使用 popen 啟動 Gnuplot 進程 \n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w"); \n    如果（！gnuplotPipe）{ \n        fprintf(stderr, "無法啟動 Gnuplot。\\n"); \n        返回1； \n    } \n   \n    // 使用Gnuplot繪圖指令，指定字體並輸出為PNG \n    fprintf(gnuplotPipe, "設定終端 png 字體 \'預設,10\' 大小 800,400\\n"); \n    fprintf(gnuplotPipe, "設定輸出 \'./../images/gnuplot_ex1.png\'\\n"); \n    fprintf(gnuplotPipe, "強度 sin(x)"); \n    // 關閉popen \n    pclose(gnuplotPipe); \n   \n    返回0； \n} \n 明確 \n 光盤下載 \n cc gnuplot_ex1_c \n ./a. 輸出 \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w6', 'text': '#include <stdio.h>  #include <gd.h>  #include <math.h> \n voiddraw_usa_flag（gdImagePtr img）； void draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n int main() {  int 寬度 = 800;  int 高度 = (int)(寬度 / 1.9); \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n 各地_美國_標誌（img）； \n FILE *outputFile = fopen("./../images/usa_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); 回傳1； } \n gdImagePngEx(img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); \n 返回0； } \n 無效draw_usa_flag（gdImagePtr img）{  int寬度= gdImageSX（img）;  int 高度 = gdImageSY(img);  int 紅、白、藍； // 國旗顏色 red = gdImageColorAllocate(img, 178, 34, 52);  // 條紋紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 blue = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n int stripe_height = 高度 / 13;  int stripe_width = 寬度； int star_size = (int)(0.0308 * 高度);  // 星星大小 \n for (int y = 0; y < height; y += stripe_height) {  if (y / stripe_height % 2 == 0) {  gdImageFilledRectangle(img, 0, y, stripe_width, y + strred_height, redred);  } else {  gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色);  }  } \n gdImageFilledRectangle(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色); \n int star_spacing_x = (int)(0.129 * 高度);  // 橫向星星之間的間距 int star_spacing_y = (int)(0.054 * height);  // 縱向星星之間的距離 int star_start_x = (int)(0.125 * height);  // 星星的起始X位置 int star_start_y = (int)(0.0485 * height);  // 最開始的Y位置 \n for (int row = 0; row < 9; row++) {  int starPerRow = (row % 2 == 0) ?  6：5； \n // 計算2、4、6和8排星星的偏移量 int offset_x = (row % 2 == 0) ?  star_spacing_x / -2 : 0; \n for (int star = 0; star < starPerRow; star++) {  int x = star_start_x + star * star_spacing_x + offset_x; \n // 旋轉角度（以弧度為單位） doublerotation_angle = M_PI / 5;  // 忘記旋轉多少度 \n int y = star_start_y + 行 * star_spacing_y;  draw_star(img, x, y, star_size, 白色, 旋轉角度);  }  }  } \n void draw_star(gdImagePtr img, int x, int y, int size, int color, doublerotation_angle) {  gdPoint 點[10]; \n for (int i = 0; i < 10; i++) { 雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度;  int 半徑 = (i % 2 == 0) ? 尺寸：尺寸/2； 點[i].x = x + 半徑 * cos(角); 點[i].y = y + 半徑 * sin(角);  } \n // 使用指定的顏色填滿星星 gdImageFilledPolygon(img,points,10,color);  } \n 明確 \n 光盤下載 \n 抄送 gd_usa_flag.c - lgd- lm \n ./a. 輸出 \n \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n void draw_roc_flag（gdImagePtr img）;  void draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int 白色, int 紅色, int 藍色); \n int main() {  // 寬度 3: 高度 2  int width = 1200;  int 高度 = (int)(寬度*2.0 / 3.0); \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n 鄰近_roc_flag（img）； \n FILE *outputFile = fopen("./roc_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); 回傳1； gdImagePngEx  (img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); 回傳0； } \n draw無效roc_flag（gdImagePtr img）{  int寬度= gdImageSX（img）;  int 高度 = gdImageSY(img);  int 紅、白、藍； int center_x = (int)(寬度/4);  int center_y = (int)(高度/4);  int sun_radius = (int)(寬度/8); \n // 標誌的顏色 red = gdImageColorAllocate(img, 242, 0, 0);  // 紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 藍色 = gdImageColorAllocate(img, 0, 41, 204);  // 藍色的 \n // 背景區域紅色 gdImageFilledRectangle(img, 0, 0, width, height, red); \n // 局部藍色區域 gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue); \n // 強度太陽 draw_white_sun(img, center_x, center_y, sun_radius,white,red,blue);  void  draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int White, int red, int blue) { 浮動角度 = 0;  int numRays = 12;  // 通知的數量 \n gdPoint點[3]； //三個頂點的陣列 \n for (int i = 0; i < numRays; i++) { 角 = i * (2 * M_PI / numRays);  float x1 = center_x + cos(角度) * sun_radius;  float y1 = center_y + sin(角度) * sun_radius; \n // 調整上下游邊的位置 float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);  float y2 = center_y + sin(角度 + 0.35) * (sun_radius * 0.5); 浮點數 x3 = center_x + cos(角度 - 0.35) * (sun_radius * 0.5);  float y3 = center_y + sin(角度 - 0.35) * (sun_radius * 0.5); \n // 設定構造的三個邊界 點[0].x = (int)x1; 點[0].y = (int)y1; 點[1].x = (int)x2; 點[1]. y = (int)y2; 點[2].x = (int)x3; 點[2].y = (int)y3; \n gdImageFilledPolygon(img, 點, 3, 白色);  }  //外圈 gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue); \n // 相似太陽內部 gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, White);  } \n 明確 \n 光盤下載 \n cc gd_roc_flag.c-lgd-lm \n ./a. 輸出 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w12', 'text': '{ pkgs }: {  deps = [  pkgs.llvmPackages_rocm.clang  pkgs.gd  pkgs.gnuplot  ];  } \n 優先給予計劃這幾項功能 \n gd是圖形其他是計算 \n #include <stdio.h> \n int main()  { \n printf("你好世界\\n");  } \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n int main() {  int 寬度 = 800; 整數高度=600； \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n FILE *outputFile = fopen("hellogd.png", "wb"); 如果（輸出檔案== NULL）{ \n fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n 返回1； } \n int 紅色 = gdImageColorAllocate(img, 255, 0, 0);  int 藍色 = gdImageColorAllocate(img, 0, 0, 255);  int black = gdImageColorAllocate(img, 0, 0, 0);  int 白色 = gdImageColorAllocate(img, 255, 255, 255);  // 長方形塗色 gdImageFilledRectangle(img, 0, 0, width, height, white);  gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色);  // 曲面形著色 gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);  // 圓形畫線 gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);  // 畫直線 gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue); \n // 施工畫線 gdPoint points[4]; 點[0].x = (int)寬度/4; 點[0].y = (int)高度*3/4; 點[1].x = 點[ 0].x + 100； 點[1].y = 點[0].y； 點[2].x = 點[1].x； 點[2].y = 點[1].y + 100 ； 點[3].x = 點[2].x - 100； 點[3].y = 點[2].y;  gdImagePolygon(img, 點, 4, 黑色); \n // 廈門著色 gdPointpoints2[4]; 點2[0].x = (int)寬度/3; 點2[0].y = (int)高度/2; 點2[1].x =點2[ 0].x + 100； 點2[1].y = 點2[0].y; 點2[2].x = 點2[1].x; 點2[2].y = 點2[ 1].y + 100； 點2[3].x = 點2[2].x - 150； 點2[3].y = 點2[2].y;  gdImageFilledPolygon(img, 點2, 4, 紅色); \n gdImagePngEx(img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); 回傳0； } \n 從近端打開此設計程式並給出上述與程式圖形並將此內容傳到github上，然後再從github下載下來如果確認圖形無誤，。 \n', 'tags': '', 'url': 'w12.html'}]};