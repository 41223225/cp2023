var tipuesearch = {"pages": [{'title': 'about', 'text': 'https://github.com/41223225/cp2023  \xa0 （個人倉儲） \n https://github.com/Liu41223244/cp2023_bg1  \xa0( 團隊倉儲 ) \n \n', 'tags': '', 'url': 'about.html'}, {'title': 'brython', 'text': 'https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學 \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中引用。 \n 也所有即將出現的對應 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時交叉 實例 引用。 \n <!-- 啟動 Brython --> \n<腳本> \n視窗.onload=函數(){ \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'brython.html'}, {'title': 'W1~W4', 'text': '下載github、replit、teams、Aunthy，把github與Aunthy連結(雙重驗證密碼)，然後再將replit與github連結(上傳檔案) \n \n 網路設定2001:288:6004:17設定完成以後cmd中的ip config/all可以查看網路設置 \n replit:先建立以太坊(python)，並與github連接，再將以太坊中設定secrets(密碼鎖)。 \n \n', 'tags': '', 'url': 'W1~W4.html'}, {'title': 'W5', 'text': '// 包含標準輸出入程式庫的標頭文件 \n// https://blog.csdn.net/weixin_38468077/article/details/101069365 \n// http://www.gnuplot.info/demo/ \n// https://github.com/sysprog21/rv32emu \n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3 \n// https://cs61c.org/fa23/ \n// https://greenteapress.com/wp/think-python-2e/ \n// https://github.com/ecalvadi/c99-examples \n// https://github.com/gouravthakur39/beginners-C-program-examples \n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples \n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf \n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf \n// https://jsomers.github.io/cbook/cbook.pdf \n// https://jsomers.github.io/cbook/index.html \n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf \n// http://cslibrary.stanford.edu/101/EssentialC.pdf \n// https://publications.gbdirect.co.uk/c_book/ \n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf \n// ***** 在replit上執行 \n// CD 下載 \n// cc gnuplot_ex1.c -o gnuplot_ex1 \n// ./gnuplot_ex1 \n#include <stdio.h> \n   \n// 主函式 \nint main() { \n    // 使用 popen 啟動 Gnuplot 進程 \n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w"); \n    如果（！gnuplotPipe）{ \n        fprintf(stderr, "無法啟動 Gnuplot。\\n"); \n        返回1； \n    } \n   \n    // 使用Gnuplot繪圖指令，指定字體並輸出為PNG \n    fprintf(gnuplotPipe, "設定終端 png 字體 \'預設,10\' 大小 800,400\\n"); \n    fprintf(gnuplotPipe, "設定輸出 \'./../images/gnuplot_ex1.png\'\\n"); \n    fprintf(gnuplotPipe, "強度 sin(x)"); \n    // 關閉popen \n    pclose(gnuplotPipe); \n   \n    返回0； \n} \n clear \n cd downloads \n cc gnuplot_ex1_c \n ./a.out \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w6', 'text': '#include <stdio.h>// 用於輸入和輸出的函數 \xa0(列印文字等等) #include <gd.h>// 繪圖工具 #include <math.h>// 計算工具 \n void draw_usa_flag(gdImagePtr img);// 繪製此檔，並以img的圖片格式匯出 void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);//繪製星星 \n int main() {  int width = 800;  int height = (int)(width / 1.9);//給予 國旗邊框 \n gdImagePtr img = gdImageCreateTrueColor(width, height);// 然後給予創建彩色圖片，圖框如上述  gdImageAlphaBlending(img, 0);// 不 允許圖像中的像素是透明或半透明(0為不允許1為允許)而此還擁有一功能，便是可用RAD:紅，綠，藍\xa0 顏色亮度，最高亮度為255 \n draw_usa_flag(img);//開始繪製美國國旗 \n FILE *outputFile = fopen("./../images/usa_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "打开输出文件时出错。\\n");  return 1;  }// 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼) \n gdImagePngEx(img, outputFile, 9);  fclose(outputFile);  gdImageDestroy(img); \n return 0; }//此段話為將圖片輸出為img檔，而這裡的9指的是將檔案壓縮最大程度(0~9) output消除之前的file(並刷新數據)gdImageDestroy(img);同上功能，只是此為刷新輸出圖片 \n //return 0\xa0會將這個整數的數值傳回給作業系統, 再這個程式結束成功結束後 \n void draw_usa_flag(gdImagePtr img) {  int width = gdImageSX(img);  int height = gdImageSY(img);  int red, white, blue;//開始繪製美國國旗，並給予外框、需另外加入的工具 \n //\xa0  red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹  white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹  blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形 \n int stripe_height = height / 13;  int stripe_width = width;  int star_size = (int)(0.0308 * height); // 星星大小 \n for (int y = 0; y < height; y += stripe_height) {  if (y / stripe_height % 2 == 0) {  gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);  } else {  gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);  }  }//這段話表示在此功能中我們將會把圖形按照基偶數給予顏色(偶數紅基數白)而高度就是上述給予的stripe_height \n gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);//將線條塗上顏色 \n int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距  int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距  int star_start_x = (int)(0.125 * height); // 星星的起始X位置  int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置 \n for (int row = 0; row < 9; row++) {  int starsPerRow = (row % 2 == 0) ? 6 : 5;// 這個迴圈用來迭代  row  變數，並根據  row  的奇偶性設定每行應該有的星星數目。在偶數行中， starsPerRow  被設為 6，而在奇數行中設為 5 \n // 计算2、4、6和8排星星的偏移量  int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0; \n for (int star = 0; star < starsPerRow; star++) {  int x = star_start_x + star * star_spacing_x + offset_x;// 迴圈用於計算每一顆星星的 x 座標。這樣的邏輯可以用來在每一行裡生成特定模式的星星排列。 \n // 旋转角度（以弧度为单位）  double rotation_angle = M_PI / 5; // 這代表著每一顆星星的旋轉角度是圓周率的五分之一。這樣的設定可以產生一種均勻分佈的星星旋轉效果 \n int y = star_start_y + row * star_spacing_y;//見算每個y座標的位置上下偏差  draw_star(img, x, y, star_size, white, rotation_angle);//在星星的圖形中載入剛剛給予的座標以及參數  }  } } \n void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {  gdPoint points[10];// 此為打開這個gd程式庫並且開始給予所需參數 \n for (int i = 0; i < 10; i++) {  double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;  int radius = (i % 2 == 0) ? size : size / 2;  points[i].x = x + radius * cos(angle);  points[i].y = y + radius * sin(angle);  }//前面已將基數偶數排的星星數量及大小畫出來，而這裡是在宣告星星的起點位置以及星星的外框形狀 \n // 用指定的颜色填充星星  gdImageFilledPolygon(img, points, 10, color);//將星星塗上顏色 } \n clear \n cd downloads \n cc gd_usa_flag.c - lgd- lm \n ./a.out \n \n \n \n \n \n #include <stdio.h>// 用於輸入和輸出的函數 \xa0(列印文字等等) \xa0 #include <gd.h>// 繪圖工具 #include <math.h>// 計算工具 \n void draw_roc_flag(gdImagePtr img);// 繪製國旗，並以img的圖片格式匯出 void draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue); // 繪太陽，並以img的圖片格式匯出，再給予會需要的工具及參數 \n int main() {  // width 3: height 2  int width = 1200;  int height = (int)(width*2.0 / 3.0);//給予圖形外框 \n gdImagePtr img = gdImageCreateTrueColor(width, height);  gdImageAlphaBlending(img, 0);// 然後給予創建彩色圖片，且不 允許圖像中的像素是透明或半透明(0為不允許1為允許) \n draw_roc_flag(img); \n FILE *outputFile = fopen("./roc_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "Error opening the output file.\\n");  return 1;  }// 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼)  gdImagePngEx(img, outputFile, 9);  fclose(outputFile);  gdImageDestroy(img);  return 0; }//此段話為將圖片輸出為img檔，而這裡的9指的是將檔案壓縮最大程度(0~9) output消除之前的file(並刷新數據)gdImageDestroy(img);同上，只是此為刷新輸出圖片 \n return 0\xa0會將這個整數的數值傳回給作業系統, 再這個程式結束成功結束後 \n void draw_roc_flag(gdImagePtr img) {  int width = gdImageSX(img);  int height = gdImageSY(img);  int red, white, blue;  int center_x = (int)(width/4);  int center_y = (int)(height/4);  int sun_radius = (int)(width/8); \n // 開始繪製國旗，並給予所需的顏色繪製位置  red = gdImageColorAllocate(img, 242, 0, 0); // Red color  white = gdImageColorAllocate(img, 255, 255, 255); // White stripes  blue = gdImageColorAllocate(img, 0, 41, 204); // Blue \n // 繪製紅色矩形區域  gdImageFilledRectangle(img, 0, 0, width, height, red); \n // 繪製藍色矩形區域  gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue); \n // 繪製太陽  draw_white_sun(img, center_x, center_y, sun_radius, white, red, blue); } void draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {  float angle = 0;  int numRays = 12; // 光芒的數量，此處為陣列數量 \n gdPoint points[3]; // 三個頂點的陣列 \n for (int i = 0; i < numRays; i++) // 這是一個迴圈，用於迭代計算每條太陽輻射射線的起點座標 {  angle = i * (2 * M_PI / numRays);// 計算了每條射線的角度，這裡使用了  i  和  numRays ，以均勻分佈的方式計算角度。  float x1 = center_x + cos(angle) * sun_radius;  float y1 = center_y + sin(angle) * sun_radius; \n float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5); \n float y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5); \n float x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5); \n float y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5); \n //計算各個頂點起點座標並且連接在一起 \n // 設定多邊形的三個頂點  points[0].x = (int)x1;  points[0].y = (int)y1;  points[1].x = (int)x2;  points[1].y = (int)y2;  points[2].x = (int)x3;  points[2].y = (int)y3; \n // points  是一個用來存儲座標的陣列 \n //將這些點轉化成x、y，以此讓這三個點可以陣列成12份 \n gdImageFilledPolygon(img, points, 3, white);  }  //將塗色外圈  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue); \n gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white); }//將太陽內部塗色 \n clear \n cd downloads \n cc gd_roc_flag.c-lgd-lm \n ./a.out \n \n \n //參照維基百科上面的日本國旗 \n //https://zh.m.wikipedia.org/zh-tw/%E6%97%A5%E6%9C%AC \n \n \n #include <stdio.h>// 用於輸入和輸出的函數 \xa0(列印文字等等) #include <gd.h>// 繪圖工具 #include <math.h>// 計算工具 \n void draw_japan_flag(gdImagePtr img);// 繪製國旗，並以img的圖片格式匯出 void draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red );// 繪製太陽，並以img的圖片格式匯出，再宣告所需工具及參數 \n int main() {  // width 3: height 2  int width = 1200;  int height = 2 * width / 3;//給予國旗外框 \n gdImagePtr img = gdImageCreateTrueColor(width, height); \n gdImageAlphaBlending(img, 0);// 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼) \n \n draw_japan_flag(img); \n FILE *outputFile = fopen("./../images/japan_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "Error opening the output file.\\n");  return 1;  }// 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼)  gdImagePngEx(img, outputFile, 9);  fclose(outputFile);  gdImageDestroy(img);  return 0; }//此段話為將圖片輸出為img檔，而這裡的9指的是將檔案壓縮最大程度(0~9) output消除之前的file(並刷新數據)gdImageDestroy(img);同上，只是此為刷新輸出圖片 \n return 0\xa0會將這個整數的數值傳回給作業系統, 再這個程式結束成功結束後。 \n void draw_japan_flag(gdImagePtr img) {  int width = gdImageSX(img);  int height = gdImageSY(img);  int red, white ;  int center_x = 0.5 * width;//這裡指的是 \xa0center_x是一半的width  int center_y = 0.5 * height;//功能同上只是在此變成 center_y是一半height  int sun_radius = 145 ; \n // 此為打開這個gd程式庫，並給予所需參數 \n // Colors for the flag  red = gdImageColorAllocate(img, 242, 0, 0); // Red color  white = gdImageColorAllocate(img, 255, 255, 255); // White stripes \n // 這裡是給予你所需要的顏色(後面三排數字分別為RAD 紅，綠，藍\xa0 顏色亮度，最高亮度為255) \n // 將白色矩形區域塗色  gdImageFilledRectangle(img, 0, 0, width, height, white); \n  // 將太陽塗色  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 3, sun_radius * 3, red); } \n clear \n cd downloads \n cc gd_roc_flag.c-lgd-lm \n ./a.out \n \n \n \n \n \n //參照維基百科上面的中國國旗 \n //https://zh.m.wikipedia.org/zh-tw/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%97%97 #include <stdio.h>// 用於輸入和輸出的函數 \xa0(列印文字等等) #include <gd.h>// 繪圖工具 #include <math.h>// 計算工具 \n void draw_chinese_flag(gdImagePtr img);// 繪製此檔，並以img的圖片格式匯出 \n int main() {  int width = 300; // 國旗寬度  int height = 200; // 國旗高度 \n gdImagePtr im = gdImageCreateTrueColor(width, height);  gdImageAlphaBlending(im, 0);// \n 給予創建彩色圖片，且不 允許圖像中的像素是透明或半透明(0為不允許1為允許) \n (將繪製圖形出圖的形式) \n draw_chinese_flag(img); \n FILE *outputFile = fopen("./../images/proc_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "打开输出文件时出错。\\n");  return 1;  }// 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼) \n gdImagePngEx(im, outputFile, 9);  fclose(outputFile);  gdImageDestroy(im); \n return 0; }//此段話為將圖片輸出為img檔，而這裡的9指的是將檔案壓縮最大程度(0~9) output消除之前的file(並刷新數據)gdImageDestroy(img);同上，只是此為刷新輸出圖片 \n return 0\xa0會將這個整數的數值傳回給作業系統, 再這個程式結束成功結束後。 \n // 声明 draw_star 函数 void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle); \n void draw_chinese_flag(gdImagePtr img) {  int width = gdImageSX(img);  int height = gdImageSY(img);  int red, yellow;//需加入這三個顏色 \n // 國旗顏色  red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景  yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星 \n // 這裡是給予你所需要的顏色(後面三排數字分別為RAD 紅，綠，藍\xa0 顏色亮度，最高亮度為255) \n // 畫紅色背景  gdImageFilledRectangle(img, 0, 0, width, height, red); \n // 設置星星的大小和位置  int star_size = (int)(0.28 * height);//星星的大小是0.28倍的height  int star_x = (int)(0.165 * width);//星星在x軸上是總寬度的0.165倍  int star_y = (int)(0.265 * height);// 星星在y軸上是總高度的0.165倍 \n // 畫大星星  draw_star(img, star_x, star_y, star_size, yellow, 11.0);// 此為打開這個gd程式庫，並 宣告繪製星星所需的參數 \n // 繪製小星星，位置根據實際國旗比例計算  double radius = 0.15 * height;//星星的半徑是0.15倍的總高度  double angle = 360 / 7 * M_PI / 179.0;//星星的五個頂點夾角  double rotation = -M_PI / 7.5;//星星整體旋轉角度  int cx = (int)(0.32 * width);//星星的位置為0.32倍的總寬度  int cy = (int)(0.27 * height);// //星星的位置為0.27倍的總高度 \n //此處為小星星的大小及夾角及選轉角度 \n for (int i = -1; i < 3; i++) //將星星迴轉四份{  int x = (int)(cx + radius * cos(i * angle + rotation));//x軸差距  int y = (int)(cy + radius * sin(i * angle + rotation));//y軸差距  draw_star(img, x, y, 19, yellow, M_PI / 5.0);//繪製星星，並給予所需參數  } } \n // 那麼這個的意思是將星星旋轉四份然後各別位置差距是上述的int x、y \n void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {  gdPoint points[10]; \n // 计算星形的五个外点和五个内点  double outer_radius = size / 2;//外部半徑為外框的2分之1  double inner_radius = size / 6;//內部半徑為外框的六分之一  double angle = M_PI / 5.0;//然後將夾角除以五 \n for (int i = 0; i < 10; i++)//選轉出時個頂點 {  double radius = (i % 2 == 0) ? outer_radius : inner_radius;//依照基偶數選擇內外頂點  double theta = rotation_angle + i * angle;// 計算每個頂點的極坐標角度，考慮到整體的旋轉角度  points[i].x = x + radius * cos(theta);// 根據極坐標轉換，計算每個頂點的 x 座標。  points[i].y = y + radius * sin(theta);// 根據極坐標轉換，計算每個頂點的 y座標。  } \n //此為將星星的外部五點及內部五點利用圓形夾角求出，並將他們連在一起形成一個五邊形的星形 \n // 使用 gdImageFilledPolygon 绘制星形  gdImageFilledPolygon(img, points, 10, color); } \n clear \n cd downloads \n cc gd_roc_flag.c-lgd-lm \n ./a.out \n \n \n \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n #define WIDTH 900 \n #define HEIGHT 600 \n #define FILENAME "south_korea_flag.png" \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 gdImagePtr im; \n \xa0\xa0\xa0\xa0 FILE *pngout; \n \xa0\xa0\xa0\xa0 int   white, black, red, blue; \n \xa0 \n \xa0\xa0\xa0\xa0 im = gdImageCreate(WIDTH, HEIGHT); \n \xa0 \n \xa0\xa0\xa0\xa0 white = gdImageColorAllocate(im, 255, 255, 255); \n \xa0\xa0\xa0\xa0 black = gdImageColorAllocate(im, 0, 0, 0); \n \xa0\xa0\xa0\xa0 red = gdImageColorAllocate(im, 205, 0, 0); \n \xa0\xa0\xa0\xa0 blue = gdImageColorAllocate(im, 0, 56, 168); \n \xa0 \n \xa0\xa0\xa0\xa0 // Background (white) \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white); \n \xa0 \n \xa0\xa0\xa0\xa0 // Blue Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc); \n \xa0 \n \xa0\xa0\xa0\xa0 // Red Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc); \n \xa0 \n \xa0\xa0 int   circleX = 385;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0\xa0 int   circleY = 262.5;\xa0\xa0  // 圓心的 Y 座標 \n \xa0\xa0 int   circleRadius = 75;\xa0\xa0\xa0  \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red); \n \xa0 \n \xa0\xa0 int   circleX2 = 515;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0 \n \xa0 int   circleY2 = 337.5; \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue); \n \xa0 \n \xa0\xa0 { \n \xa0 \n \xa0 \n \xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 340;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 90;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 200;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 260;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 270;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 210;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +12); \n gdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white); \n } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black); \n \xa0 \n gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 400, 734, 490, white); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white); \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 97;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 267;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 212, 734, 118, white); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 277;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 217;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Save image \n FILE *outputFile = fopen( "./../images/korea_flag.png" ,  "wb" ); \n if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0 fprintf(stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0 return   1; \n } \n \xa0\xa0 gdImagePngEx(im, outputFile, 9); \n \xa0\xa0\xa0\xa0\xa0\xa0 fclose(outputFile); \n \xa0\xa0\xa0\xa0\xa0\xa0 gdImageDestroy(im); \n \xa0\xa0\xa0\xa0\xa0\xa0 return   0; \n \xa0\xa0 } \n clear \n cd downloads \n cc gd_roc_flag.c-lgd-lm \n ./a.out \n \n \n \n \n \n \n #include <stdio.h> #include <gd.h> #include <math.h> \xa0 void draw_uk_flag(gdImagePtr img); void fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color); \xa0 int main() { \xa0\xa0\xa0\xa0// 设置国旗的宽和高 \xa0\xa0\xa0\xa0int width = 1200; \xa0\xa0\xa0\xa0int height = width / 2; \xa0 \xa0\xa0\xa0\xa0// 创建图像 \xa0\xa0\xa0\xa0gdImagePtr img = gdImageCreateTrueColor(width, height); \xa0\xa0\xa0\xa0gdImageAlphaBlending(img, 0); \xa0 \xa0\xa0\xa0\xa0// 绘制英国国旗 \xa0\xa0\xa0\xa0draw_uk_flag(img); \xa0 \xa0\xa0\xa0\xa0// 将图像保存到文件 \xa0\xa0\xa0\xa0FILE *outputFile = fopen("./../images/uk_flag.png", "wb"); \xa0\xa0\xa0\xa0if (outputFile == NULL) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0fprintf(stderr, "打开输出文件时发生错误。\\n"); \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return 1; \xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0gdImagePngEx(img, outputFile, 9); \xa0\xa0\xa0\xa0fclose(outputFile); \xa0\xa0\xa0\xa0gdImageDestroy(img); \xa0\xa0\xa0\xa0return 0; } \xa0 \xa0 \xa0 void draw_uk_flag(gdImagePtr img) { \xa0\xa0\xa0\xa0int width = gdImageSX(img); \xa0\xa0\xa0\xa0int height = gdImageSY(img); \xa0 \xa0\xa0\xa0\xa0int red, white, blue; \xa0\xa0\xa0\xa0red = gdImageColorAllocate(img, 204, 0, 0);\xa0\xa0\xa0\xa0\xa0\xa0 // 红色 \xa0\xa0\xa0\xa0white = gdImageColorAllocate(img, 255, 255, 255); // 白色 \xa0\xa0\xa0\xa0blue = gdImageColorAllocate(img, 0, 0, 153);\xa0\xa0\xa0\xa0\xa0 // 蓝色 \xa0 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, 0, width, height, blue); \xa0 \xa0 \xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0\xa0{ \xa0\xa0\xa0\xa0int line_thickness = 100; \xa0\xa0\xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0\xa0\xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0 \xa0\xa0\xa0\xa0// 绘制白色斜线 \xa0\xa0\xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 600; \xa0\xa0\xa0\xa0x2 = 1200; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0\xa0\xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 0; \xa0\xa0\xa0\xa0x2 = 1200; \xa0\xa0\xa0\xa0y2 = 600; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); } \xa0\xa0{ \xa0\xa0\xa0\xa0int line_thickness = 33; \xa0\xa0\xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0 \xa0\xa0\xa0\xa0// 绘制红色斜线 \xa0\xa0\xa0\xa0x1 = 566; \xa0\xa0\xa0\xa0y1 = 300; \xa0\xa0\xa0\xa0x2 = 1166; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 1233; \xa0\xa0\xa0\xa0y1 = 600; \xa0\xa0\xa0\xa0x2 = 633; \xa0\xa0\xa0\xa0y2 = 300; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 566; \xa0\xa0\xa0\xa0y1 = 300; \xa0\xa0\xa0\xa0x2 = -33; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 600; \xa0\xa0\xa0\xa0y1 = 316.5; \xa0\xa0\xa0\xa0x2 = 0; \xa0\xa0\xa0\xa0y2 = 616.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0\xa0} \xa0\xa0{ \xa0\xa0int line_thickness = 33; \xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0 \xa0\xa0// 绘制\xa0 斜线 \xa0\xa0x1 = 0; \xa0\xa0y1 = 600; \xa0\xa0x2 = 1200; \xa0\xa0y2 = 0; \xa0\xa0gdImageLine(img, x1, y1, x2, y2, red ); \xa0 \xa0 \xa0\xa0x1 = 1200; \xa0\xa0\xa0\xa0y1 = 16.5; \xa0\xa0\xa0\xa0x2 = 600; \xa0\xa0\xa0\xa0y2 = 316.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0 \xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 583.5; \xa0\xa0\xa0\xa0x2 = 600; \xa0\xa0\xa0\xa0y2 = 283.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0 \xa0\xa0} \xa0 \xa0\xa0\xa0\xa0// 绘制白色十字 \xa0\xa0\xa0\xa0int cross_width = width / 32; \xa0\xa0\xa0\xa0int cross_arm_width = width / 32; \xa0\xa0\xa0\xa0int center_x = width / 2; \xa0\xa0\xa0\xa0int center_y = height / 2; \xa0 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white); \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white); \xa0 \xa0\xa0\xa0\xa0// 绘制红色十字 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red); \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red); }\n clear \n cd downloads \n cc gd_roc_flag.c-lgd-lm \n ./a.out \n \n \n \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'W8-w9', 'text': '分組 \n', 'tags': '', 'url': 'W8-w9.html'}, {'title': 'w12', 'text': '{ pkgs }: {  deps = [  pkgs.llvmPackages_rocm.clang  pkgs.gd  pkgs.gnuplot  ];  } \n 優先給予計劃這幾項功能 \n gd是圖形其他是計算 \n #include <stdio.h> \n int main()  { \n printf("你好世界\\n");  } \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n int main() {  int 寬度 = 800; 整數高度=600； \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n FILE *outputFile = fopen("hellogd.png", "wb"); 如果（輸出檔案== NULL）{ \n fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n 返回1； } \n int 紅色 = gdImageColorAllocate(img, 255, 0, 0);  int 藍色 = gdImageColorAllocate(img, 0, 0, 255);  int black = gdImageColorAllocate(img, 0, 0, 0);  int 白色 = gdImageColorAllocate(img, 255, 255, 255);  // 長方形塗色 gdImageFilledRectangle(img, 0, 0, width, height, white);  gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色);  // 曲面形著色 gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);  // 圓形畫線 gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);  // 畫直線 gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue); \n // 施工畫線 gdPoint points[4]; 點[0].x = (int)寬度/4; 點[0].y = (int)高度*3/4; 點[1].x = 點[ 0].x + 100； 點[1].y = 點[0].y； 點[2].x = 點[1].x； 點[2].y = 點[1].y + 100 ； 點[3].x = 點[2].x - 100； 點[3].y = 點[2].y;  gdImagePolygon(img, 點, 4, 黑色); \n // 廈門著色 gdPointpoints2[4]; 點2[0].x = (int)寬度/3; 點2[0].y = (int)高度/2; 點2[1].x =點2[ 0].x + 100； 點2[1].y = 點2[0].y; 點2[2].x = 點2[1].x; 點2[2].y = 點2[ 1].y + 100； 點2[3].x = 點2[2].x - 150； 點2[3].y = 點2[2].y;  gdImageFilledPolygon(img, 點2, 4, 紅色); \n gdImagePngEx(img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); 回傳0； } \n \n \n 從近端打開此設計方案並給出上述與方案圖形把此內容傳到github上，然後再從github下載下來如果確認圖形無誤，。 \n \n', 'tags': '', 'url': 'w12.html'}, {'title': 'w14', 'text': '以下影片為replit無法開啟倉儲時 \n Wink on the Web.mp4 \n 從近端前往github.mp4 \n', 'tags': '', 'url': 'w14.html'}, {'title': 'w16', 'text': '#include <stdio.h> #include <math.h> \n #define TIME_STEP 0.01 // 时间步长 #define SIMULATION_TIME 10.0 // 模拟时间 \n // 物体的参数 #define m1 2.0 #define m2 3.0 #define k1 0.5 #define k2 1.0 #define k3 1.5 #define c1 0.25 #define c2 0.33 #define c3 0.5 #define X1_initial 1.0 #define X2_initial -0.5 #define V0 0.0 \n // 计算阻尼力 double dampingForce(double c, double v) {  return -c * v; } \n // 模拟物体运动 void simulateMotion() {  double X1 = X1_initial;  double X2 = X2_initial;  double V1 = V0;  double V2 = V0; \n FILE *fp;  fp = fopen("motion_data.txt", "w"); \n for (double t = 0; t <= SIMULATION_TIME; t += TIME_STEP) {  double F1 = -k1 * (X1 - 0) - c1 * (V1 - 0); // 第一个物体受到的合力  double F2 = -k2 * (X2 - X1) - c2 * (V2 - V1); // 第二个物体受到的合力  double F3 = -k3 * (X2 - 0) - c3 * (V2 - 0); // 第二个物体受到的合力 \n double a1 = F1 / m1; // 第一个物体的加速度  double a2 = F2 / m2; // 第二个物体的加速度 \n // 更新速度和位置  V1 += a1 * TIME_STEP;  V2 += a2 * TIME_STEP; \n X1 += V1 * TIME_STEP;  X2 += V2 * TIME_STEP; \n // 在文件写入时记录 m1 和 m2 的位置和速度数据  fprintf(fp, "%lf %lf %lf %lf %lf\\n", t, X1, X2, V1, V2);  } \n  fclose(fp); } \n int main() {  simulateMotion();  return 0; } \n 加上 \n #include <stdio.h> \n int main() { FILE *gnuplotPipe = popen("gnuplot", "w"); if (gnuplotPipe) { fprintf(gnuplotPipe, "set terminal png\\n"); fprintf(gnuplotPipe, "set output \'motion_plot.png\'\\n"); fprintf(gnuplotPipe, "set xlabel \'Time\'\\n"); fprintf(gnuplotPipe, "set ylabel \'Position / Velocity\'\\n"); fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines title \'m1 position\', \'motion_data.txt\' using 1:3 with lines title \'m2 position\', \'motion_data.txt\' using 1:4 with lines title \'m1 velocity\', \'motion_data.txt\' using 1:5 with lines title \'m2 velocity\'\\n"); fprintf(gnuplotPipe, "exit\\n"); fflush(gnuplotPipe); pclose(gnuplotPipe); } else { printf("Error opening pipe to Gnuplot.\\n"); } return 0; } \n 會呈現出 \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'w16.html'}, {'title': '如何使用wink', 'text': '如何使用wink.mp4 \n 如何使用wink(下).mp4 \n 影片中未提到如何把影片上傳到倉儲，是因為每個人都有自己的方法。 \n 我是先上傳到onedrive，再將影片連結分享到倉儲(如下圖) \n 記得把編輯改成觀看，以免影片不小心被他人刪除等等。 \n \n', 'tags': '', 'url': '如何使用wink.html'}, {'title': 'Exercises111', 'text': '// 包含標準輸出入程式庫的標頭文件 \n #include <stdio.h> \n \xa0 \n // 主函式 \n int   main() { \n \xa0\xa0\xa0\xa0 // Open a file to write displacement and velocity data \n \xa0\xa0\xa0\xa0 FILE   *outputFile =  fopen ( "motion_data.txt" ,  "w" ); \n \xa0\xa0\xa0\xa0 if   (!outputFile) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Failed to create data file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Simulate motion for 10 seconds and calculate displacement and velocity, while writing data to the file \n \xa0\xa0\xa0\xa0 double   x = 0.2;\xa0  // Initial displacement \n \xa0\xa0\xa0\xa0 double   v = 0.0;\xa0  // Initial velocity \n \xa0\xa0\xa0\xa0 double   dt = 0.01;  // Time step \n \xa0\xa0\xa0\xa0 double   t = 0.0;\xa0  // Time \n \xa0 \n \xa0\xa0\xa0\xa0 while   (t <= 10.0) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 double   acceleration = (-10.0 * x - 0.5 * v) / 1.0;  // Modified system parameters here \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 v += acceleration * dt; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 x += v * dt; \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (outputFile,  "%lf %lf %lf\\n" , t, x, v); \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 t += dt; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Close the data file \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0 \n \xa0\xa0\xa0\xa0 // Start a Gnuplot process using popen \n \xa0\xa0\xa0\xa0 FILE   *gnuplotPipe = popen( "gnuplot -persistent" ,  "w" ); \n \xa0\xa0\xa0\xa0 if   (!gnuplotPipe) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Failed to start Gnuplot.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Use Gnuplot plotting commands, specify font and output as PNG \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set terminal pngcairo enhanced font \'default,10\' size 800,400\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set output \'./../images/motion_plot.png\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set title \'Displacement and Velocity vs. Time\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set xlabel \'Time (s)\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set ylabel \'Displacement (m)\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe, "plot  \'motion_data.txt\'   using   1:2 with lines lw 2 title  \'Displacement\' , \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \'motion_data.txt\'   using   1:3 with lines lw 2 title  \'Velocity\' \\n"); \n \xa0 \n \xa0\xa0\xa0\xa0 // Close the Gnuplot process \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "exit\\n" ); \n \xa0\xa0\xa0\xa0 pclose(gnuplotPipe); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n', 'tags': '', 'url': 'Exercises111.html'}, {'title': '練習1', 'text': '編寫一個 C 程式來列印您的姓名、出生日期和手機號碼 \n 解釋:printf打印字\xa0 \xa0 \xa0前面就是輸入前面的字:後面就是後面的字 \n \\n"是換行 \n \n 寫一個C 程序，反向列印下列字元。 測試字元 ：\'J\'、\'M\'、\'O\' 預期輸出 ： JMO 的反面是 OMJ \n 解釋: printf執行函數char char1\xa0char char2\xa0char char3是分別代表三個字母， \n 而char1\xa0char2\xa0char3相當於他們的代號，而它從char1~3變成3~1表示順序顛 \n 倒。 return 0; : 表示程序执行成功并返回值 0，这是主函数的结束标志。 \n %c%c%c  对应着  char1 、 char2 、 char3 ，而  %c%c%c  对应着  char3 、 char2 、 char1 ，所以它们被打印出来时就呈现出了反转的效果。 \n \n 用 C 語言編寫一個程序，讀取名字、姓氏和出生年份，並依序顯示姓名和年份。預期輸出：輸入您的名字：林輸入您的姓氏：峻安輸入您的出生年份：2005林峻安 2005 \n 解釋:char  firstname[ 20 ], lastname[ 20 ];  // 声明字符数组以存储名和姓，每个数组最大长度为20个字符。 \xa0 \n int  bir_year;  // 声明一个整数变量 \'bir_year\' 用于存储出生年份 \n   printf ( "Input your firstname: " );  // 提示用户输入他们的名字 \n printf ( "Input your year of birth: " );  // 提示用户输入他们的出生年份 \n printf ( "%s %s %d\\n" , firstname, lastname, bir_year);  // 打印名字、姓氏和出生年份。   return   0 ;  // 返回0以指示程序成功执行。 \n 而在此我犯了一個大錯誤，我不能直接把這些資料輸入在上面，而是應該輸入在./.a.out那邊 \n \n 測試數據：天數：1800預期輸出：年：4週：48天：4 \n 解釋:這個程式就是將日期先除年分，而禮拜這裡先出現weeks = (days % 365)/7其中days%365就是已經把年份除掉剩下的天數下去除七天(一星期)，而最後的就是把總天數減掉剩餘天數 \n \n 編寫一個 C 程式來讀取金額（整數值）並將該金額分解為盡可能少的鈔票數量。 \n 可能的錢幣有 100、50、20、10、5、2 和 1 \n \n 寫一個 C 程式來讀取 5 個數字以及它們之間的所有奇數總和。 測試資料 \n 輸入第一個數字：1 輸入第二個數字：3 輸入第三個數字：5 輸入第四個數字：7 輸入第五個數字：9 預期輸出： 所有奇數總和：25 點 \n 解釋: int   main ()  {  int  j, numbers[ 5 ], total= 0 ;  // 声明一个数组来存储5个数字和一个用于总和的变量   \n // 提示用户输入第一个数字   printf ( "\\nInput the first number: " );  \n // 从用户输入中读取并存储第一个数字   scanf ( "%d" , &numbers[ 0 ]); \n // 循环提示用户输入剩余的四个数字   for  (j =  1 ; j <  5 ; j++) {  printf ( "Input the next number: " );  scanf ( "%d" , &numbers[j]); }  \n // 计算数字的总和   for  (j =  0 ; j <  5 ; j++) { total += numbers[j]; }  \n // 打印数字的总和   printf ( "The total is: %d\\n" , total);  return   0 ; } \n int  j, numbers[ 5 ], total= 0 ;  // 声明一个数组来存储5个数字和一个用于总和的变量   \n // 使用循环提示用户输入五个数字，并将它们存储在数组中   for  (j =  0 ; j <  5 ; j++) {  printf ( "\\nInput the %s number: " , j ==  0  ?  "first"  : (j ==  1  ?  "second"  : (j ==  2  ?  "third"  : (j ==  3  ?  "fourth"  :  "fifth" ))));  scanf ( "%d" , &numbers[j]); }  \n // 遍历数组，检查每个数字是否为奇数，如果是奇数，则加到总和中   for (j =  0 ; j <  5 ; j++) {  if ((numbers[j] %  2 ) !=  0 ) {  // 检查数字是否为奇数  total += numbers[j];  \n // 将奇数添加到总和中  } } \n \n 寫一個 C 程式來列印一個數字及其平方和立方體，從 1 開始列印 n 行。 接受使用者的行數（n，整數） \n 測試資料： 輸入行數：7 期望輸出： \n 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 \n \n . 編寫一個 C 程式來建立 7 天的枚舉資料類型，並以整數常數顯示它們的值。 \n . 編寫一個 C 程式來建立 7 天的枚舉資料類型，並以整數常數顯示它們的值。 週日=0 \n 週一=1 \n 週二=2 \n 週三 =3  \n 週四 =4  \n 週五=5 \n 週六=6 \n \n 寫一個 C 程序，在一行上列印 3 個數字，從 1 開始，列印 n 行。接受使用者的行數（n，整數）。 測試資料： 輸入行數：7 預期輸出： \n 1 2 3  4 5 6  7 8 9  10 11 12  13 14 15  16 17 18 \n \n 編寫一個C 程式來取得您正在使用的C 版本。 預期輸出 \n 我們用的是C18！ \n \n', 'tags': '', 'url': '練習1.html'}, {'title': '練習2', 'text': '\n \n \n #include < stdio.h > \n void main() \n { \n \xa0 /* 印出 Hello */ \n printf("Hello World!"); \n } \n \n #include <stdio.h> int main() { int a = 1; int A = 8; int b = 2, c; c = A - a + b; /* 輸出 a, A, b, c 到螢幕 */ printf( "a = %d, A = %d, b = %d, c = %d ", a, A, b, c ); return 0; } \n \n 6c#include < stdio.h > \n \n \n \n \n int main() \n { \n char x, y; \n x = \'a\'; \n y = (char)97; \n /* 輸出 x, y, x, 最後一個是以 ASCII 值顯示 y */ \n printf( " x = %c, y = %c, ASCII of y = %d", x, y, y ); \n return 0; \n } \n \n \n #include < stdio.h > \n \xa0 \n void main() { \n \xa0\xa0\xa0\xa0 int a; \n \xa0 \n \xa0\xa0\xa0\xa0 // 將 a 設為 3，然後對其進行邏輯 NOT 運算 \n \xa0\xa0\xa0\xa0 a = 3; \n \xa0\xa0\xa0\xa0 printf("%d\\n", !a);\xa0 // 非（NOT）運算，輸出 0 \n \xa0 \n \xa0\xa0\xa0\xa0 // 將 a 設為 0，然後對其進行邏輯 NOT 運算 \n \xa0\xa0\xa0\xa0 a = 0; \n \xa0\xa0\xa0\xa0 printf("%d\\n", !a);\xa0 // 非（NOT）運算，輸出 1 \n } \n \n \n \n \n \n #include < stdio.h > \n \xa0 \n void main() { \n \xa0\xa0\xa0\xa0 // 1 AND 3，兩個運算元都為真，結果為真（1） \n \xa0\xa0\xa0\xa0 printf("%d\\n", 1 && 3); \n \xa0 \n \xa0\xa0\xa0\xa0 // 0 AND 0，其中一個運算元為假，結果為假（0） \n \xa0\xa0\xa0\xa0 printf("%d\\n", 0 && 0); \n \xa0 \n \xa0\xa0\xa0\xa0 // 2 AND 2，兩個運算元都為真，結果為真（1） \n \xa0\xa0\xa0\xa0 printf("%d\\n", 2 && 2); \n } \n \n \n #include < stdio.h > \n int main() \n { \n int a = 1; \n int A = 8; \n int b = 2, c; \n c = A - a + b; \n /* 輸出 a, A, b, c 到螢幕 */ \n printf( "a = %d, A = %d, b = %d, c = %d ", a, A, b, c ); \n return 0; \n } \n \n \n #include< stdio.h > \n \xa0 \n void main() { \n \xa0\xa0\xa0\xa0 int a, b; \n \xa0\xa0\xa0\xa0 a = 15; \n \xa0\xa0\xa0\xa0 b = 1; \n \xa0 \n \xa0\xa0\xa0\xa0 // 位元 OR 運算 (a OR b) \n \xa0\xa0\xa0\xa0 printf("%d \\n", a | b); \n \xa0 \n \xa0\xa0\xa0\xa0 // 位元 AND 運算 (a AND b) \n \xa0\xa0\xa0\xa0 printf("%d \\n", a & b); \n \xa0 \n \xa0\xa0\xa0\xa0 // 位元 XOR 運算 (a XOR b) \n \xa0\xa0\xa0\xa0 printf("%d \\n", a ^ b); \n \xa0 \n \xa0\xa0\xa0\xa0 // 位元左移 1 位 (a 左移 1 位) \n \xa0\xa0\xa0\xa0 printf("%d \\n", a <<  1 ); \n \xa0 \n \xa0\xa0\xa0\xa0 // 位元右移 1 位 (a 右移 1 位) \n \xa0\xa0\xa0\xa0 printf("%d \\n", a >> 1); \n \xa0 \n \xa0\xa0\xa0\xa0 // a 的補數運算 (~a) \n \xa0\xa0\xa0\xa0 printf("%d \\n", ~a); \n } \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '練習2.html'}, {'title': '如何繪製國旗', 'text': '1首先給予圖形們必要工具 \n \n \n #include <stdio.h> 用於輸入和輸出的函數 \xa0(列印文字等等) \xa0\xa0 #include <gd.h>\xa0 繪圖工具 #include <math.h>\xa0 計算工具 \n 繪製此檔，並以img的圖片格式匯出 \n void draw_圖名_flag( gdImagePtr  img); \n \n 記住必須先給予圖形外框才能創建圖片，可選擇給予比例或者長度 \n int main() { int width = xxx; int height = (int)(width * x.x); \n \n 然後給予創建彩色圖片，且不 允許圖像中的像素是透明或半透明(0為不允許1為允許) \n (將繪製圖形出圖的形式) \n gdImagePtr img = gdImageCreateTrueColor(width, height); gdImageAlphaBlending(img, 0); \n 此段話為把圖檔存在哪裡，並且嘗試打開，如打開失敗將會輸入一個非零的值( 錯誤碼) \n FILE *outputFile = fopen("./../images(前面為將圖檔存在哪裡)/圖名_flag.png", "wb"); \n if (outputFile == NULL) { \n fprintf(stderr, "Error opening the output file.\\n"); \n return 1; \n } \n 此段話為將圖片輸出為img檔，而這裡的9指的是將檔案壓縮最大程度(0~9) output消除之前的file(並刷新數據)gdImageDestroy(img);同上，只是此為刷新輸出圖片 \n return 0\xa0會將這個整數的數值傳回給作業系統, 在這個程式結束成功結束後。 \n gdImagePngEx(img, outputFile, 9); fclose(outputFile); gdImageDestroy(img); return 0; \n 2給予圖形們常用的工具 \n 此為打開這個gd程式庫，並給予所需參數 \n void draw_usa_flag(gdImagePtr img) { int width = gdImageSX(img); int height = gdImageSY(img); int red, white, blue \xa0 \n 這裡是給予你所需要的顏色(後面三排數字分別為RAD 紅，綠，藍\xa0 顏色亮度，最高亮度為255) \n red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹 white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹 blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形 \n \n \n', 'tags': '', 'url': '如何繪製國旗.html'}, {'title': '期末總結', 'text': '個人評分75 \n A: 是否按照進度明確標示倉儲的改版歷程 \n Q:未完成每周筆記內容，少了幾周。 \n B: 是否根據 \xa0 IPv4 與 IPv6 \xa0 網路環境設定進行作法討論 \n Q:是，以按照下載中的tincy、w11_a的內容修改網路 \n C: 是否就 \xa0 Replit、s.cycu.org 與 localhost \xa0 情境下對個人與分組倉儲進行設定操作 \n Q:目前會使用這三種，只是s.cycu.org需要ipv6的網路設定，因此除在學校我不會使用(不會自行設定筆電的ipv6) \n D: 是否完成 上課內容 中的 Exercises \n Q:是 \n E: 是否完成 \xa0 w2-w5 \xa0 週任務中的 Exercises111 \n Q:是 \n F: 是否完成 \xa0 w6-w7 \xa0 週任務中的練習一與練習二 \n Q:已完成練習一，練習二未完成 \n G: 是否完成 C 結合 gd 繪圖程式庫, 畫出 \xa0 PROC ( 規格 ), \xa0 United Kingdom ( 規格 ), \xa0 Japan ( 規格 )與 \xa0 South Korea ( 規格 ) Flags \n Q:已畫出來 \n H: 是否完成 w16 Final Project \n Q:已完成 \n', 'tags': '', 'url': '期末總結.html'}]};