var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/41223225/cp2023  \xa0 （以太坊） \n https://github.com/Liu41223244/cp2023_bg1  \xa0( 團體文件 ) \n \n', 'tags': '', 'url': '關於.html'}, {'title': '布萊頓', 'text': 'https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中引用。 \n 也所有即將出現的對應 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時交叉 實例 引用。 \n <!-- 啟動 Brython --> \n<腳本> \n視窗.onload=函數(){ \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': '布萊頓.html'}, {'title': 'W1~W4', 'text': '下載github、replit、teams、Aunthy，把github與Aunthy連結(雙重驗證密碼)，然後再將replit與github連結(上傳檔案) \n \n 網路設定2001:288:6004:17設定完成以後cmd中的ip config/all可以查看網路設置 \n replit:先建立以太坊(python)，並與github連接，再將以太坊中設定secrets(密碼鎖)。 \n \n', 'tags': '', 'url': 'W1~W4.html'}, {'title': 'W5', 'text': '// 包含標準輸出入程式庫的標頭文件 \n// https://blog.csdn.net/weixin_38468077/article/details/101069365 \n// http://www.gnuplot.info/demo/ \n// https://github.com/sysprog21/rv32emu \n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3 \n// https://cs61c.org/fa23/ \n// https://greenteapress.com/wp/think-python-2e/ \n// https://github.com/ecalvadi/c99-examples \n// https://github.com/gouravthakur39/beginners-C-program-examples \n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples \n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf \n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf \n// https://jsomers.github.io/cbook/cbook.pdf \n// https://jsomers.github.io/cbook/index.html \n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf \n// http://cslibrary.stanford.edu/101/EssentialC.pdf \n// https://publications.gbdirect.co.uk/c_book/ \n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf \n// ***** 在replit上執行 \n// CD 下載 \n// cc gnuplot_ex1.c -o gnuplot_ex1 \n// ./gnuplot_ex1 \n#include <stdio.h> \n   \n// 主函式 \nint main() { \n    // 使用 popen 啟動 Gnuplot 進程 \n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w"); \n    如果（！gnuplotPipe）{ \n        fprintf(stderr, "無法啟動 Gnuplot。\\n"); \n        返回1； \n    } \n   \n    // 使用Gnuplot繪圖指令，指定字體並輸出為PNG \n    fprintf(gnuplotPipe, "設定終端 png 字體 \'預設,10\' 大小 800,400\\n"); \n    fprintf(gnuplotPipe, "設定輸出 \'./../images/gnuplot_ex1.png\'\\n"); \n    fprintf(gnuplotPipe, "強度 sin(x)"); \n    // 關閉popen \n    pclose(gnuplotPipe); \n   \n    返回0； \n} \n clear \n cd downloads \n cc gnuplot_ex1_c \n ./a.out \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w6', 'text': '#include <stdio.h>  #include <gd.h>  #include <math.h> \n voiddraw_usa_flag（gdImagePtr img）； void draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n int main() {  int 寬度 = 800;  int 高度 = (int)(寬度 / 1.9); \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n 各地_美國_標誌（img）； \n FILE *outputFile = fopen("./../images/usa_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); 回傳1； } \n gdImagePngEx(img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); \n 返回0； } \n 無效draw_usa_flag（gdImagePtr img）{  int寬度= gdImageSX（img）;  int 高度 = gdImageSY(img);  int 紅、白、藍； // 國旗顏色 red = gdImageColorAllocate(img, 178, 34, 52);  // 條紋紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 blue = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n int stripe_height = 高度 / 13;  int stripe_width = 寬度； int star_size = (int)(0.0308 * 高度);  // 星星大小 \n for (int y = 0; y < height; y += stripe_height) {  if (y / stripe_height % 2 == 0) {  gdImageFilledRectangle(img, 0, y, stripe_width, y + strred_height, redred);  } else {  gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色);  }  } \n gdImageFilledRectangle(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色); \n int star_spacing_x = (int)(0.129 * 高度);  // 橫向星星之間的間距 int star_spacing_y = (int)(0.054 * height);  // 縱向星星之間的距離 int star_start_x = (int)(0.125 * height);  // 星星的起始X位置 int star_start_y = (int)(0.0485 * height);  // 最開始的Y位置 \n for (int row = 0; row < 9; row++) {  int starPerRow = (row % 2 == 0) ?  6：5； \n // 計算2、4、6和8排星星的偏移量 int offset_x = (row % 2 == 0) ?  star_spacing_x / -2 : 0; \n for (int star = 0; star < starPerRow; star++) {  int x = star_start_x + star * star_spacing_x + offset_x; \n // 旋轉角度（以弧度為單位） doublerotation_angle = M_PI / 5;  // 忘記旋轉多少度 \n int y = star_start_y + 行 * star_spacing_y;  draw_star(img, x, y, star_size, 白色, 旋轉角度);  } }  } \n void draw_star(gdImagePtr img, int x, int y, int size, int color, doublerotation_angle) {  gdPoint 點[10]; \n for (int i = 0; i < 10; i++) { 雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度;  int 半徑 = (i % 2 == 0) ? 尺寸：尺寸/2； 點[i].x = x + 半徑 * cos(角); 點[i].y = y + 半徑 * sin(角);  } \n // 使用指定的顏色填滿星星 gdImageFilledPolygon(img,points,10,color);  } \n 明確 \n 海報下載 \n 抄送 gd_usa_flag.c - lgd- lm \n 。/A。 輸出 \n \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n void draw_roc_flag（gdImagePtr img）;  void draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int 白色, int 紅色, int 藍色); \n int main() {  // 寬度 3: 高度 2  int width = 1200;  int 高度 = (int)(寬度*2.0 / 3.0); \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n 鄰近_roc_flag（img）； \n FILE *outputFile = fopen("./roc_flag.png", "wb");  if (outputFile == NULL) {  fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); 回傳1； gdImagePngEx  (img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); 回傳0； } \n drawroVinc_flag（gdImagePtr img）{  int寬度= gdImageSX（img）;  int 高度 = gdImageSY(img);  int 紅、白、藍； int center_x = (int)(寬度/4);  int center_y = (int)(高度/4);  int sun_radius = (int)(寬度/8); \n // 標誌的顏色 red = gdImageColorAllocate(img, 242, 0, 0);  // 紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 藍色 = gdImageColorAllocate(img, 0, 41, 204);  // 藍色的 \n // 背景區域紅色 gdImageFilledRectangle(img, 0, 0, width, height, red); \n // 局部藍色區域 gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue); \n // 強度太陽 draw_white_sun(img, center_x, center_y, sun_radius,white,red,blue);  void  draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int White, int red, int blue) { 浮動角度 = 0;  int numRays = 12;  // 通知數量 \n gdPoint點[3]； //三個頂點的橋樑 \n for (int i = 0; i < numRays; i++) { 角 = i * (2 * M_PI / numRays);  float x1 = center_x + cos(角度) * sun_radius;  float y1 = center_y + sin(角度) * sun_radius; \n // 調整上下游邊的位置 float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);  float y2 = center_y + sin(角度 + 0.35) * (sun_radius * 0.5); 浮點數 x3 = center_x + cos(角度 - 0.35) * (sun_radius * 0.5);  float y3 = center_y + sin(角度 - 0.35) * (sun_radius * 0.5); \n // 設定構造的三個邊界 點[0].x = (int)x1; 點[0].y = (int)y1; 點[1].x = (int)x2; 點[1].  y = (int)y2; 點[2].x = (int)x3; 點[2].y = (int)y3; \n gdImageFilledPolygon(img, 點, 3, 白色);  }  //外圈 gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue); \n // 相似太陽內部 gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, White);  } \n 明確 \n 海報下載 \n cc gd_roc_flag.c-lgd-lm \n 。/A。 輸出 \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n void   draw_japan_flag(gdImagePtr img); \n void   draw_red_sun(gdImagePtr img,  int   x,  int   y,  int   size,  int   color); \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 int   originalWidth = 1200; \n \xa0\xa0\xa0\xa0 int   originalHeight = ( int )(originalWidth * 2.0 / 3.0); \n \xa0\xa0\xa0\xa0 gdImagePtr img = gdImageCreateTrueColor(originalWidth, originalHeight); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(img, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 draw_japan_flag(img); \n \xa0 \n \xa0\xa0\xa0\xa0 // 新的宽度和高度以适应 "images" 文件夹 \n \xa0\xa0\xa0\xa0 int   newWidth = 600; \n \xa0\xa0\xa0\xa0 int   newHeight = ( int )(newWidth * 2.0 / 3.0); \n \xa0 \n \xa0\xa0\xa0\xa0 // 创建新图像并进行缩放 \n \xa0\xa0\xa0\xa0 gdImagePtr resizedImage = gdImageCreateTrueColor(newWidth, newHeight); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(resizedImage, 0); \n \xa0\xa0\xa0\xa0 gdImageCopyResampled(resizedImage, img, 0, 0, 0, 0, newWidth, newHeight, originalWidth, originalHeight); \n \xa0 \n \xa0\xa0 FILE   *outputFile =  fopen ( "./../images/japan_flag.png" ,  "wb" ); \n \xa0\xa0\xa0\xa0 if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 gdImagePng(resizedImage, outputFile); \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0\xa0\xa0\xa0 gdImageDestroy(img); \n \xa0\xa0\xa0\xa0 gdImageDestroy(resizedImage); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \xa0 \n void   draw_japan_flag(gdImagePtr img) { \n \xa0\xa0\xa0\xa0 int   width = gdImageSX(img); \n \xa0\xa0\xa0\xa0 int   height = gdImageSY(img); \n \xa0 \n \xa0\xa0\xa0\xa0 // 创建一个白色背景 \n \xa0\xa0\xa0\xa0 int   white = gdImageColorAllocate(img, 255, 255, 255); \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, width - 1, height - 1, white); \n \xa0 \n \xa0\xa0\xa0\xa0 // 绘制红色圆圈（太阳） \n \xa0\xa0\xa0\xa0 int   red = gdImageColorAllocate(img, 255, 0, 0); \n \xa0\xa0\xa0\xa0 int   center_x = width / 2; \n \xa0\xa0\xa0\xa0 int   center_y = height / 2; \n \xa0\xa0\xa0\xa0 int   radius = ( int )((width * 2) / 3); \n \xa0\xa0\xa0\xa0 draw_red_sun(img, center_x, center_y, radius, red); \n } \n \xa0 \n void   draw_red_sun(gdImagePtr img,  int   x,  int   y,  int   size,  int   color) { \n \xa0\xa0 // 減小 size 的值,例如將他的值減半 \n \xa0\xa0 size = size / 2; \n \xa0\xa0\xa0\xa0 gdImageArc(img, x, y, size, size, 0, 360, color); \n \xa0\xa0\xa0\xa0 gdImageFillToBorder(img, x, y, color, color); \n } \n \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n void draw_chinese_flag(gdImagePtr img); \n \xa0 \n int main() { \n \xa0\xa0\xa0\xa0 int width = 300;  // 國旗寬度 \n \xa0\xa0\xa0\xa0 int height = 200;  // 國旗高度 \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePtr im = gdImageCreateTrueColor(width, height); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(im, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 draw_chinese_flag(im); \n \xa0 \n \xa0\xa0\xa0\xa0 FILE *outputFile = fopen( "./../images/proc_flag.png" ,  "wb" ); \n \xa0\xa0\xa0\xa0 if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf(stderr,  "打開输出文件時出錯。\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePngEx(im, outputFile, 9); \n \xa0\xa0\xa0\xa0 fclose(outputFile); \n \xa0\xa0\xa0\xa0 gdImageDestroy(im); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \xa0 \n // 聲明 draw_star 函數 \n void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle); \n \xa0 \n void draw_chinese_flag(gdImagePtr img) { \n \xa0\xa0\xa0\xa0 int width = gdImageSX(img); \n \xa0\xa0\xa0\xa0 int height = gdImageSY(img); \n \xa0\xa0\xa0\xa0 int red, yellow; \n \xa0 \n \xa0\xa0\xa0\xa0 // 國旗顏色 \n \xa0\xa0\xa0\xa0 red = gdImageColorAllocate(img, 255, 0, 0);  // 紅色背景 \n \xa0\xa0\xa0\xa0 yellow = gdImageColorAllocate(img, 255, 255, 0);  // 黃色星星 \n \xa0 \n \xa0\xa0\xa0\xa0 // 畫紅色背景 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, width, height, red); \n \xa0 \n \xa0\xa0\xa0\xa0 // 設置星星的大小和位置 \n \xa0\xa0\xa0\xa0 int star_size = (int)(0.28 * height); \n \xa0\xa0\xa0\xa0 int star_x = (int)(0.165 * width); \n \xa0\xa0\xa0\xa0 int star_y = (int)(0.265 * height); \n \xa0 \n \xa0\xa0\xa0\xa0 // 畫大星星 \n \xa0\xa0\xa0\xa0 draw_star(img, star_x, star_y, star_size, yellow, 11.0); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製小星星，位置根據實際國旗比例計算 \n \xa0\xa0\xa0\xa0 double radius = 0.15 * height; \n \xa0\xa0\xa0\xa0 double angle = 360 / 7 * M_PI / 179.0; \n \xa0\xa0\xa0\xa0 double rotation = -M_PI / 7.5; \n \xa0\xa0\xa0\xa0 int cx = (int)(0.32 * width); \n \xa0\xa0\xa0\xa0 int cy = (int)(0.27 * height); \n \xa0 \n \xa0\xa0\xa0\xa0 for   (int i = -1; i < 3; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int x = (int)(cx + radius * cos(i * angle + rotation)); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 int y = (int)(cy + radius * sin(i * angle + rotation)); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 draw_star(img, x, y, 19, yellow, M_PI / 5.0); \n \xa0\xa0\xa0\xa0 } \n } \n \xa0 \n void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) { \n \xa0\xa0\xa0\xa0 gdPoint points[10]; \n \xa0 \n \xa0\xa0\xa0\xa0 // 計算星形的五個外點和五個内點 \n \xa0\xa0\xa0\xa0 double outer_radius = size / 2; \n \xa0\xa0\xa0\xa0 double inner_radius = size / 6; \n \xa0\xa0\xa0\xa0 double angle = M_PI / 5.0; \n \xa0 \n \xa0\xa0\xa0\xa0 for   (int i = 0; i < 10; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 double radius = (i % 2 == 0) ? outer_radius : inner_radius; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 double theta = rotation_angle + i * angle; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].x = x + radius * cos(theta); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 points[i].y = y + radius * sin(theta); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // 使用 gdImageFilledPolygon 繪製星形 \n \xa0\xa0\xa0\xa0 gdImageFilledPolygon(img, points, 10, color); \n } \n \n \n \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n #define WIDTH 900 \n #define HEIGHT 600 \n #define FILENAME "south_korea_flag.png" \n \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 gdImagePtr im; \n \xa0\xa0\xa0\xa0 FILE *pngout; \n \xa0\xa0\xa0\xa0 int   white, black, red, blue; \n \xa0 \n \xa0\xa0\xa0\xa0 im = gdImageCreate(WIDTH, HEIGHT); \n \xa0 \n \xa0\xa0\xa0\xa0 white = gdImageColorAllocate(im, 255, 255, 255); \n \xa0\xa0\xa0\xa0 black = gdImageColorAllocate(im, 0, 0, 0); \n \xa0\xa0\xa0\xa0 red = gdImageColorAllocate(im, 205, 0, 0); \n \xa0\xa0\xa0\xa0 blue = gdImageColorAllocate(im, 0, 56, 168); \n \xa0 \n \xa0\xa0\xa0\xa0 // Background (white) \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white); \n \xa0 \n \xa0\xa0\xa0\xa0 // Blue Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc); \n \xa0 \n \xa0\xa0\xa0\xa0 // Red Circle (Yin-Yang Symbol) \n \xa0\xa0\xa0\xa0 gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc); \n \xa0 \n \xa0\xa0 int   circleX = 385;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0\xa0 int   circleY = 262.5;\xa0\xa0  // 圓心的 Y 座標 \n \xa0\xa0 int   circleRadius = 75;\xa0\xa0\xa0  \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red); \n \xa0 \n \xa0\xa0 int   circleX2 = 515;\xa0\xa0\xa0  // 圓心的 X 座標 \n \xa0 \n \xa0 int   circleY2 = 337.5; \n \xa0 \n \xa0\xa0 // 繪製圓形 \n \xa0\xa0 gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue); \n \xa0 \n \xa0\xa0 { \n \xa0 \n \xa0 \n \xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 340;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 90;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 200;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 260;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 270;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 210;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +12); \n gdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white); \n } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black); \n \xa0 \n gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 400, 734, 490, white); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white); \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 330;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 520;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 190;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 350;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black); \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black); \n \xa0 \n \xa0\xa0 int   startX2 = 213;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 330;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 133;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 390;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth ); \n gdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +14); \n gdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 232, 426, 206, 448, white); \n \xa0 \n \xa0\xa0 } \n \xa0\xa0 { \n \xa0\xa0\xa0\xa0 // 起點和終點位置 \n \xa0 \n \xa0\xa0 int   startX = 564;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY = 97;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX = 704;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY = 267;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth = 23;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX, startY, endX, endY, black); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth -10); \n gdImageLine(im, 624, 212, 734, 118, white); \n \xa0 \n \xa0\xa0\xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n \xa0\xa0 gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black); \n \xa0 \n \xa0\xa0 int   startX2 = 553;\xa0\xa0  \n \xa0\xa0 // 線的起點 X 座標 \n \xa0 \n \xa0\xa0 int   startY2 = 277;\xa0  \n \xa0\xa0 // 線的起點 Y 座標 \n \xa0 \n \xa0\xa0 int   endX2 = 633;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 X 座標 \n \xa0 \n \xa0\xa0 int   endY2 = 217;\xa0\xa0\xa0  \n \xa0\xa0 // 線的終點 Y 座標 \n \xa0 \n \xa0\xa0 int   lineWidth2 = 25;\xa0  // 線的寬度 \n \xa0 \n \xa0\xa0 // 繪製線段 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +8); \n \xa0\xa0 gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth +10); \n gdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white); \n \xa0 \n \xa0\xa0 gdImageSetThickness(im, lineWidth); \n gdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImageSetThickness(im, lineWidth +30); \n gdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white); \n \xa0 \n \xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Save image \n FILE *outputFile = fopen( "./../images/korea_flag.png" ,  "wb" ); \n if   (outputFile == NULL) { \n \xa0\xa0\xa0\xa0 fprintf(stderr,  "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0 return   1; \n } \n \xa0\xa0 gdImagePngEx(im, outputFile, 9); \n \xa0\xa0\xa0\xa0\xa0\xa0 fclose(outputFile); \n \xa0\xa0\xa0\xa0\xa0\xa0 gdImageDestroy(im); \n \xa0\xa0\xa0\xa0\xa0\xa0 return   0; \n \xa0\xa0 } \n \n \n \n \n \n #include <stdio.h> #include <gd.h> #include <math.h> \xa0 void draw_uk_flag(gdImagePtr img); void fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color); \xa0 int main() { \xa0\xa0\xa0\xa0// 设置国旗的宽和高 \xa0\xa0\xa0\xa0int width = 1200; \xa0\xa0\xa0\xa0int height = width / 2; \xa0 \xa0\xa0\xa0\xa0// 创建图像 \xa0\xa0\xa0\xa0gdImagePtr img = gdImageCreateTrueColor(width, height); \xa0\xa0\xa0\xa0gdImageAlphaBlending(img, 0); \xa0 \xa0\xa0\xa0\xa0// 绘制英国国旗 \xa0\xa0\xa0\xa0draw_uk_flag(img); \xa0 \xa0\xa0\xa0\xa0// 将图像保存到文件 \xa0\xa0\xa0\xa0FILE *outputFile = fopen("./../images/uk_flag.png", "wb"); \xa0\xa0\xa0\xa0if (outputFile == NULL) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0fprintf(stderr, "打开输出文件时发生错误。\\n"); \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return 1; \xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0gdImagePngEx(img, outputFile, 9); \xa0\xa0\xa0\xa0fclose(outputFile); \xa0\xa0\xa0\xa0gdImageDestroy(img); \xa0\xa0\xa0\xa0return 0; } \xa0 \xa0 \xa0 void draw_uk_flag(gdImagePtr img) { \xa0\xa0\xa0\xa0int width = gdImageSX(img); \xa0\xa0\xa0\xa0int height = gdImageSY(img); \xa0 \xa0\xa0\xa0\xa0int red, white, blue; \xa0\xa0\xa0\xa0red = gdImageColorAllocate(img, 204, 0, 0);\xa0\xa0\xa0\xa0\xa0\xa0 // 红色 \xa0\xa0\xa0\xa0white = gdImageColorAllocate(img, 255, 255, 255); // 白色 \xa0\xa0\xa0\xa0blue = gdImageColorAllocate(img, 0, 0, 153);\xa0\xa0\xa0\xa0\xa0 // 蓝色 \xa0 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, 0, width, height, blue); \xa0 \xa0 \xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0\xa0{ \xa0\xa0\xa0\xa0int line_thickness = 100; \xa0\xa0\xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0\xa0\xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0 \xa0\xa0\xa0\xa0// 绘制白色斜线 \xa0\xa0\xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 600; \xa0\xa0\xa0\xa0x2 = 1200; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0\xa0\xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 0; \xa0\xa0\xa0\xa0x2 = 1200; \xa0\xa0\xa0\xa0y2 = 600; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); } \xa0\xa0{ \xa0\xa0\xa0\xa0int line_thickness = 33; \xa0\xa0\xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0 \xa0\xa0\xa0\xa0// 绘制红色斜线 \xa0\xa0\xa0\xa0x1 = 566; \xa0\xa0\xa0\xa0y1 = 300; \xa0\xa0\xa0\xa0x2 = 1166; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 1233; \xa0\xa0\xa0\xa0y1 = 600; \xa0\xa0\xa0\xa0x2 = 633; \xa0\xa0\xa0\xa0y2 = 300; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 566; \xa0\xa0\xa0\xa0y1 = 300; \xa0\xa0\xa0\xa0x2 = -33; \xa0\xa0\xa0\xa0y2 = 0; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0 \xa0\xa0\xa0\xa0x1 = 600; \xa0\xa0\xa0\xa0y1 = 316.5; \xa0\xa0\xa0\xa0x2 = 0; \xa0\xa0\xa0\xa0y2 = 616.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, red); \xa0\xa0} \xa0\xa0{ \xa0\xa0int line_thickness = 33; \xa0\xa0gdImageSetThickness(img, line_thickness); \xa0 \xa0\xa0int x1, y1, x2, y2, x3, y3; \xa0 \xa0\xa0// 绘制\xa0 斜线 \xa0\xa0x1 = 0; \xa0\xa0y1 = 600; \xa0\xa0x2 = 1200; \xa0\xa0y2 = 0; \xa0\xa0gdImageLine(img, x1, y1, x2, y2, red ); \xa0 \xa0 \xa0\xa0x1 = 1200; \xa0\xa0\xa0\xa0y1 = 16.5; \xa0\xa0\xa0\xa0x2 = 600; \xa0\xa0\xa0\xa0y2 = 316.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0 \xa0\xa0x1 = 0; \xa0\xa0\xa0\xa0y1 = 583.5; \xa0\xa0\xa0\xa0x2 = 600; \xa0\xa0\xa0\xa0y2 = 283.5; \xa0\xa0\xa0\xa0gdImageLine(img, x1, y1, x2, y2, white); \xa0 \xa0 \xa0\xa0} \xa0 \xa0\xa0\xa0\xa0// 绘制白色十字 \xa0\xa0\xa0\xa0int cross_width = width / 32; \xa0\xa0\xa0\xa0int cross_arm_width = width / 32; \xa0\xa0\xa0\xa0int center_x = width / 2; \xa0\xa0\xa0\xa0int center_y = height / 2; \xa0 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white); \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white); \xa0 \xa0\xa0\xa0\xa0// 绘制红色十字 \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red); \xa0\xa0\xa0\xa0gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red); } \n \n \n \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w12', 'text': '{ pkgs }: {  deps = [  pkgs.llvmPackages_rocm.clang  pkgs.gd  pkgs.gnuplot  ];  } \n 優先給予計劃這幾項功能 \n gd是圖形其他是計算 \n #include <stdio.h> \n int main()  { \n printf("你好世界\\n");  } \n #include <stdio.h>  #include <gd.h>  #include <math.h> \n int main() {  int 寬度 = 800; 整數高度=600； \n gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  gdImageAlphaBlending(img, 0); \n FILE *outputFile = fopen("hellogd.png", "wb"); 如果（輸出檔案== NULL）{ \n fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n 返回1； } \n int 紅色 = gdImageColorAllocate(img, 255, 0, 0);  int 藍色 = gdImageColorAllocate(img, 0, 0, 255);  int black = gdImageColorAllocate(img, 0, 0, 0);  int 白色 = gdImageColorAllocate(img, 255, 255, 255);  // 長方形塗色 gdImageFilledRectangle(img, 0, 0, width, height, white);  gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色);  // 曲面形著色 gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);  // 圓形畫線 gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);  // 畫直線 gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue); \n // 施工畫線 gdPoint points[4]; 點[0].x = (int)寬度/4; 點[0].y = (int)高度*3/4; 點[1].x = 點[ 0].x + 100； 點[1].y = 點[0].y； 點[2].x = 點[1].x； 點[2].y = 點[1].y + 100 ； 點[3].x = 點[2].x - 100； 點[3].y = 點[2].y;  gdImagePolygon(img, 點, 4, 黑色); \n // 廈門著色 gdPointpoints2[4]; 點2[0].x = (int)寬度/3; 點2[0].y = (int)高度/2; 點2[1].x =點2[ 0].x + 100； 點2[1].y = 點2[0].y; 點2[2].x = 點2[1].x; 點2[2].y = 點2[ 1].y + 100； 點2[3].x = 點2[2].x - 150； 點2[3].y = 點2[2].y;  gdImageFilledPolygon(img, 點2, 4, 紅色); \n gdImagePngEx(img, 輸出檔, 9);  fclose(輸出檔);  gdImageDestroy(img); 回傳0； } \n 從近端打開此設計方案並給出上述與方案圖形把此內容傳到github上，然後再從github下載下來如果確認圖形無誤，。 \n \n', 'tags': '', 'url': 'w12.html'}, {'title': 'w14', 'text': '以下影片為replit無法開啟倉儲時 \n Wink on the Web.mp4 \n 從近端前往github.mp4 \n', 'tags': '', 'url': 'w14.html'}, {'title': '如何使用wink', 'text': '如何使用wink.mp4 \n 如何使用wink(下).mp4 \n 影片中未提到如何把影片上傳到倉儲，是因為每個人都有自己的方法。 \n 我是先上傳到onedrive，再將影片連結分享到倉儲(如下圖) \n 記得把編輯改成觀看，以免影片不小心被他人刪除等等。 \n \n', 'tags': '', 'url': '如何使用wink.html'}, {'title': 'Exercises111', 'text': '// 包含標準輸出入程式庫的標頭文件 \n #include <stdio.h> \n \xa0 \n // 主函式 \n int   main() { \n \xa0\xa0\xa0\xa0 // Open a file to write displacement and velocity data \n \xa0\xa0\xa0\xa0 FILE   *outputFile =  fopen ( "motion_data.txt" ,  "w" ); \n \xa0\xa0\xa0\xa0 if   (!outputFile) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Failed to create data file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Simulate motion for 10 seconds and calculate displacement and velocity, while writing data to the file \n \xa0\xa0\xa0\xa0 double   x = 0.2;\xa0  // Initial displacement \n \xa0\xa0\xa0\xa0 double   v = 0.0;\xa0  // Initial velocity \n \xa0\xa0\xa0\xa0 double   dt = 0.01;  // Time step \n \xa0\xa0\xa0\xa0 double   t = 0.0;\xa0  // Time \n \xa0 \n \xa0\xa0\xa0\xa0 while   (t <= 10.0) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 double   acceleration = (-10.0 * x - 0.5 * v) / 1.0;  // Modified system parameters here \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 v += acceleration * dt; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 x += v * dt; \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (outputFile,  "%lf %lf %lf\\n" , t, x, v); \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 t += dt; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Close the data file \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0 \n \xa0\xa0\xa0\xa0 // Start a Gnuplot process using popen \n \xa0\xa0\xa0\xa0 FILE   *gnuplotPipe = popen( "gnuplot -persistent" ,  "w" ); \n \xa0\xa0\xa0\xa0 if   (!gnuplotPipe) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr,  "Failed to start Gnuplot.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   1; \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 // Use Gnuplot plotting commands, specify font and output as PNG \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set terminal pngcairo enhanced font \'default,10\' size 800,400\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set output \'./../images/motion_plot.png\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set title \'Displacement and Velocity vs. Time\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set xlabel \'Time (s)\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "set ylabel \'Displacement (m)\'\\n" ); \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe, "plot  \'motion_data.txt\'   using   1:2 with lines lw 2 title  \'Displacement\' , \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \'motion_data.txt\'   using   1:3 with lines lw 2 title  \'Velocity\' \\n"); \n \xa0 \n \xa0\xa0\xa0\xa0 // Close the Gnuplot process \n \xa0\xa0\xa0\xa0 fprintf (gnuplotPipe,  "exit\\n" ); \n \xa0\xa0\xa0\xa0 pclose(gnuplotPipe); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n', 'tags': '', 'url': 'Exercises111.html'}, {'title': '練習1', 'text': '', 'tags': '', 'url': '練習1.html'}, {'title': '期末總結', 'text': 'A: 是否按照進度明確標示倉儲的改版歷程 \n Q:未完成每周筆記內容，少了幾周。 \n B: 是否根據 \xa0 IPv4 與 IPv6 \xa0 網路環境設定進行作法討論 \n Q:是，以按照下載中的tincy、w11_a的內容修改網路 \n C: 是否就 \xa0 Replit、s.cycu.org 與 localhost \xa0 情境下對個人與分組倉儲進行設定操作 \n Q:目前會使用這三種，只是s.cycu.org需要ipv6的網路設定，因此除在學校我不會使用(不會自行設定筆電的ipv6) \n D: 是否完成 上課內容 中的 Exercises \n E: 是否完成 \xa0 w2-w5 \xa0 週任務中的 Exercises111 \n F: 是否完成 \xa0 w6-w7 \xa0 週任務中的練習一與練習二 \n G: 是否完成 C 結合 gd 繪圖程式庫, 畫出 \xa0 PROC ( 規格 ), \xa0 United Kingdom ( 規格 ), \xa0 Japan ( 規格 )與 \xa0 South Korea ( 規格 ) Flags \n Q:以畫出來 \n H: 是否完成 w16 Final Project \n Q:沒完成 \n', 'tags': '', 'url': '期末總結.html'}]};